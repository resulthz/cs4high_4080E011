# HTTP Status Code
https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81
```
1xx訊息
這一類型的狀態碼，代表請求已被接受，需要繼續處理。這類回應是臨時回應，只包含狀態行和某些可選的回應頭資訊，並以空行結束。由於HTTP/1.0協定中沒有定義任何1xx狀態碼，所以除非在某些試驗條件下，伺服器禁止向此類客戶端傳送1xx回應。[4] 這些狀態碼代表的回應都是資訊性的，標示客戶應該採取的其他行動。
100 Continue
伺服器已經接收到請求頭，並且客戶端應繼續傳送請求主體（在需要傳送身體的請求的情況下：例如，POST請求），或者如果請求已經完成，忽略這個回應。伺服器必須在請求完成後向客戶端傳送一個最終回應。要使伺服器檢查請求的頭部，客戶端必須在其初始請求中傳送Expect: 100-continue作為頭部，並在傳送正文之前接收100 Continue狀態代碼。回應代碼417期望失敗表示請求不應繼續。[2]
101 Switching Protocols
伺服器已經理解了客戶端的請求，並將通過Upgrade訊息頭通知客戶端採用不同的協定來完成這個請求。在傳送完這個回應最後的空行後，伺服器將會切換到在Upgrade訊息頭中定義的那些協定。[5]
只有在切換新的協定更有好處的時候才應該採取類似措施。例如，切換到新的HTTP版本（如HTTP/2）比舊版本更有優勢，或者切換到一個即時且同步的協定（如WebSocket）以傳送利用此類特性的資源。
102 Processing（WebDAV；RFC 2518）
WebDAV請求可能包含許多涉及檔案操作的子請求，需要很長時間才能完成請求。該代碼表示​​伺服器已經收到並正在處理請求，但無回應可用。[6]這樣可以防止客戶端超時，並假設請求遺失。

2xx成功
這一類型的狀態碼，代表請求已成功被伺服器接收、理解、並接受。[2]
200 OK
請求已成功，請求所希望的回應頭或資料體將隨此回應返回。實際的回應將取決於所使用的請求方法。在GET請求中，回應將包含與請求的資源相對應的實體。在POST請求中，回應將包含描述或操作結果的實體。[7]
201 Created
請求已經被實現，而且有一個新的資源已經依據請求的需要而建立，且其URI已經隨Location頭資訊返回。假如需要的資源無法及時建立的話，應當返回'202 Accepted'。[8]
202 Accepted
伺服器已接受請求，但尚未處理。最終該請求可能會也可能不會被執行，並且可能在處理發生時被禁止。[9]
203 Non-Authoritative Information（自HTTP / 1.1起）
伺服器是一個轉換代理伺服器（transforming proxy，例如網路加速器），以200 OK狀態碼為起源，但回應了原始回應的修改版本。[10][11]
204 No Content
伺服器成功處理了請求，沒有返回任何內容。[12]
205 Reset Content
伺服器成功處理了請求，但沒有返回任何內容。與204回應不同，此回應要求請求者重設文件視圖。[13]
206 Partial Content（RFC 7233）
伺服器已經成功處理了部分GET請求。類似於FlashGet或者迅雷這類的HTTP 下載工具都是使用此類回應實現斷點續傳或者將一個大文件分解為多個下載段同時下載。[14]
207 Multi-Status（WebDAV；RFC 4918）
代表之後的訊息體將是一個XML訊息，並且可能依照之前子請求數量的不同，包含一系列獨立的回應代碼。[15]
208 Already Reported （WebDAV；RFC 5842）
DAV繫結的成員已經在（多狀態）回應之前的部分被列舉，且未被再次包含。
226 IM Used （RFC 3229）
伺服器已經滿足了對資源的請求，對實體請求的一個或多個實體操作的結果表示。[16]

3xx重新導向
這類狀態碼代表需要客戶端採取進一步的操作才能完成請求。通常，這些狀態碼用來重新導向，後續的請求位址（重新導向目標）在本次回應的Location域中指明。[2]
若且唯若後續的請求所使用的方法是GET或者HEAD時，用戶瀏覽器才可以在沒有用戶介入的情況下自動提交所需要的後續請求。客戶端應當自動監測無限迴圈重新導向（例如：A→B→C→……→A或A→A），因為這會導致伺服器和客戶端大量不必要的資源消耗。按照HTTP/1.0版規範的建議，瀏覽器不應自動存取超過5次的重新導向。[17]
300 Multiple Choices
被請求的資源有一系列可供選擇的回饋資訊，每個都有自己特定的位址和瀏覽器驅動的商議資訊。用戶或瀏覽器能夠自行選擇一個首選的位址進行重新導向。[18]
除非這是一個HEAD請求，否則該回應應當包括一個資源特性及位址的列表的實體，以便用戶或瀏覽器從中選擇最合適的重新導向位址。這個實體的格式由Content-Type定義的格式所決定。瀏覽器可能根據回應的格式以及瀏覽器自身能力，自動作出最合適的選擇。當然，RFC 2616規範並沒有規定這樣的自動選擇該如何進行。
如果伺服器本身已經有了首選的回饋選擇，那麼在Location中應當指明這個回饋的URI；瀏覽器可能會將這個Location值作為自動重新導向的位址。此外，除非額外指定，否則這個回應也是可快取的。
301 Moved Permanently
被請求的資源已永久移動到新位置，並且將來任何對此資源的參照都應該使用本回應返回的若干個URI之一。如果可能，擁有連結編輯功能的客戶端應當自動把請求的位址修改為從伺服器回饋回來的位址。[19]除非額外指定，否則這個回應也是可快取的。
新的永久性的URI應當在回應的Location域中返回。除非這是一個HEAD請求，否則回應的實體中應當包含指向新的URI的超連結及簡短說明。
如果這不是一個GET或者HEAD請求，那麼瀏覽器禁止自動進行重新導向，除非得到用戶的確認，因為請求的條件可能因此發生變化。
注意：對於某些使用HTTP/1.0協定的瀏覽器，當它們傳送的POST請求得到了一個301回應的話，接下來的重新導向請求將會變成GET方式。
302 Found
要求客戶端執行臨時重新導向（原始描述短語為「Moved Temporarily」）。[20]由於這樣的重新導向是臨時的，客戶端應當繼續向原有位址傳送以後的請求。只有在Cache-Control或Expires中進行了指定的情況下，這個回應才是可快取的。
新的臨時性的URI應當在回應的Location域中返回。除非這是一個HEAD請求，否則回應的實體中應當包含指向新的URI的超連結及簡短說明。
如果這不是一個GET或者HEAD請求，那麼瀏覽器禁止自動進行重新導向，除非得到用戶的確認，因為請求的條件可能因此發生變化。
注意：雖然RFC 1945和RFC 2068規範不允許客戶端在重新導向時改變請求的方法，但是很多現存的瀏覽器將302回應視作為303回應，並且使用GET方式存取在Location中規定的URI，而無視原先請求的方法。[21]因此狀態碼303和307被添加了進來，用以明確伺服器期待客戶端進行何種反應。[22]
303 See Other
對應目前請求的回應可以在另一個URI上被找到，當回應於POST（或PUT / DELETE）接收到回應時，客戶端應該假定伺服器已經收到資料，並且應該使用單獨的GET訊息發出重新導向。[23]這個方法的存在主要是為了允許由指令碼啟用的POST請求輸出重新導向到一個新的資源。這個新的URI不是原始資源的替代參照。同時，303回應禁止被快取。當然，第二個請求（重新導向）可能被快取。
新的URI應當在回應的Location域中返回。除非這是一個HEAD請求，否則回應的實體中應當包含指向新的URI的超連結及簡短說明。
注意：許多HTTP/1.1版以前的瀏覽器不能正確理解303狀態。如果需要考慮與這些瀏覽器之間的互動，302狀態碼應該可以勝任，因為大多數的瀏覽器處理302回應時的方式恰恰就是上述規範要求客戶端處理303回應時應當做的。
304 Not Modified
表示資源在由請求頭中的If-Modified-Since或If-None-Match參數指定的這一版本之後，未曾被修改。在這種情況下，由於客戶端仍然具有以前下載的副本，因此不需要重新傳輸資源。[24]
305 Use Proxy
被請求的資源必須通過指定的代理才能被存取。Location域中將給出指定的代理所在的URI資訊，接收者需要重複傳送一個單獨的請求，通過這個代理才能存取相應資源。只有原始伺服器才能建立305回應。許多HTTP客戶端（像是Mozilla[25]和Internet Explorer）都沒有正確處理這種狀態代碼的回應，主要是出於安全考慮。[26]
注意：RFC 2068中沒有明確305回應是為了重新導向一個單獨的請求，而且只能被原始伺服器建立。忽視這些限制可能導致嚴重的安全後果。
306 Switch Proxy
在最新版的規範中，306狀態碼已經不再被使用。最初是指「後續請求應使用指定的代理」。[27]
307 Temporary Redirect
在這種情況下，請求應該與另一個URI重複，但後續的請求應仍使用原始的URI。 與302相反，當重新發出原始請求時，不允許更改請求方法。 例如，應該使用另一個POST請求來重複POST請求。[28]
308 Permanent Redirect (RFC 7538)
請求和所有將來的請求應該使用另一個URI重複。 307和308重複302和301的行為，但不允許HTTP方法更改。 例如，將表單提交給永久重新導向的資源可能會順利進行。[29]

4xx客戶端錯誤
這類的狀態碼代表了客戶端看起來可能發生了錯誤，妨礙了伺服器的處理。除非回應的是一個HEAD請求，否則伺服器就應該返回一個解釋目前錯誤狀況的實體，以及這是臨時的還是永久性的狀況。這些狀態碼適用於任何請求方法。瀏覽器應當向用戶顯示任何包含在此類錯誤回應中的實體內容。[30]
如果錯誤發生時客戶端正在傳送資料，那麼使用TCP的伺服器實現應當仔細確保在關閉客戶端與伺服器之間的連接之前，客戶端已經收到了包含錯誤資訊的封包。如果客戶端在收到錯誤資訊後繼續向伺服器傳送資料，伺服器的TCP棧將向客戶端傳送一個重設封包，以清除該客戶端所有還未辨識的輸入緩衝，以免這些資料被伺服器上的應用程式讀取並干擾後者。
400 Bad Request
由於明顯的客戶端錯誤（例如，格式錯誤的請求語法，太大的大小，無效的請求訊息或欺騙性路由請求），伺服器不能或不會處理該請求。[31]
401 Unauthorized（RFC 7235）
參見：HTTP基本認證、HTTP摘要認證
類似於403 Forbidden，401語意即「未認證」，即用戶沒有必要的憑據。[32]該狀態碼表示目前請求需要用戶驗證。該回應必須包含一個適用於被請求資源的WWW-Authenticate資訊頭用以詢問用戶資訊。客戶端可以重複提交一個包含恰當的Authorization頭資訊的請求。[33]如果目前請求已經包含了Authorization憑證，那麼401回應代表著伺服器驗證已經拒絕了那些憑證。如果401回應包含了與前一個回應相同的身分驗證詢問，且瀏覽器已經至少嘗試了一次驗證，那麼瀏覽器應當向用戶展示回應中包含的實體資訊，因為這個實體資訊中可能包含了相關診斷資訊。
注意：當網站（通常是網站域名）禁止IP位址時，有些網站狀態碼顯示的401，表示該特定位址被拒絕存取網站。
402 Payment Required
該狀態碼是為了將來可能的需求而預留的。該狀態碼最初的意圖可能被用作某種形式的數字現金或線上支付方案的一部分，但幾乎沒有哪家服務商使用，而且這個狀態碼通常不被使用。如果特定開發人員已超過請求的每日限制，Google Developers API會使用此狀態碼。[34]
403 Forbidden
主條目：HTTP 403
伺服器已經理解請求，但是拒絕執行它。與401回應不同的是，身分驗證並不能提供任何幫助，而且這個請求也不應該被重複提交。如果這不是一個HEAD請求，而且伺服器希望能夠講清楚為何請求不能被執行，那麼就應該在實體內描述拒絕的原因。當然伺服器也可以返回一個404回應，假如它不希望讓客戶端獲得任何資訊。
404 Not Found
主條目：HTTP 404
請求失敗，請求所希望得到的資源未被在伺服器上發現，但允許用戶的後續請求。[35]沒有資訊能夠告訴用戶這個狀況到底是暫時的還是永久的。假如伺服器知道情況的話，應當使用410狀態碼來告知舊資源因為某些內部的組態機制問題，已經永久的不可用，而且沒有任何可以跳轉的位址。404這個狀態碼被廣泛應用於當伺服器不想揭示到底為何請求被拒絕或者沒有其他適合的回應可用的情況下。
405 Method Not Allowed
請求行中指定的請求方法不能被用於請求相應的資源。該回應必須返回一個Allow頭資訊用以表示出目前資源能夠接受的請求方法的列表。例如，需要通過POST呈現資料的表單上的GET請求，或唯讀資源上的PUT請求。
鑑於PUT，DELETE方法會對伺服器上的資源進行寫操作，因而絕大部分的網頁伺服器都不支援或者在預設組態下不允許上述請求方法，對於此類請求均會返回405錯誤。
406 Not Acceptable
參見：內容協商
請求的資源的內容特性無法滿足請求頭中的條件，因而無法生成回應實體，該請求不可接受。[36]
除非這是一個HEAD請求，否則該回應就應當返回一個包含可以讓用戶或者瀏覽器從中選擇最合適的實體特性以及網址列表的實體。實體的格式由Content-Type頭中定義的媒體類型決定。瀏覽器可以根據格式及自身能力自行作出最佳選擇。但是，規範中並沒有定義任何作出此類自動選擇的標準。
407 Proxy Authentication Required（RFC 2617）
與401回應類似，只不過客戶端必須在代理伺服器上進行身分驗證。[37]代理伺服器必須返回一個Proxy-Authenticate用以進行身分詢問。客戶端可以返回一個Proxy-Authorization資訊頭用以驗證。
408 Request Timeout
請求超時。根據HTTP規範，客戶端沒有在伺服器預備等待的時間內完成一個請求的傳送，客戶端可以隨時再次提交這一請求而無需進行任何更改。[38]
409 Conflict
表示因為請求存在衝突無法處理該請求，例如多個同步更新之間的編輯衝突。
410 Gone
表示所請求的資源不再可用，將不再可用。當資源被有意地刪除並且資源應被清除時，應該使用這個。在收到410狀態碼後，用戶應停止再次請求資源。[39]但大多數伺服器端不會使用此狀態碼，而是直接使用404狀態碼。

5xx伺服器錯誤
表示伺服器無法完成明顯有效的請求。[57]這類狀態碼代表了伺服器在處理請求的過程中有錯誤或者異常狀態發生，也有可能是伺服器意識到以目前的軟硬體資源無法完成對請求的處理。除非這是一個HEAD請求，否則伺服器應當包含一個解釋目前錯誤狀態以及這個狀況是臨時的還是永久的解釋資訊實體。瀏覽器應當向用戶展示任何在目前回應中被包含的實體。這些狀態碼適用於任何回應方法。[58]
500 Internal Server Error
通用錯誤訊息，伺服器遇到了一個未曾預料的狀況，導致了它無法完成對請求的處理。沒有給出具體錯誤資訊。[59]
501 Not Implemented
伺服器不支援目前請求所需要的某個功能。當伺服器無法辨識請求的方法，並且無法支援其對任何資源的請求。[60]（例如，網路服務API的新功能）
502 Bad Gateway
作為閘道器或者代理工作的伺服器嘗試執行請求時，從上游伺服器接收到無效的回應。[61]
503 Service Unavailable
由於臨時的伺服器維護或者過載，伺服器目前無法處理請求。這個狀況是暫時的，並且將在一段時間以後恢復。[62]如果能夠預計延遲時間，那麼回應中可以包含一個Retry-After頭用以標明這個延遲時間。如果沒有給出這個Retry-After資訊，那麼客戶端應當以處理500回應的方式處理它。
504 Gateway Timeout
作為閘道器或者代理工作的伺服器嘗試執行請求時，未能及時從上游伺服器（URI標識出的伺服器，例如HTTP、FTP、LDAP）或者輔助伺服器（例如DNS）收到回應。[63]
注意：某些代理伺服器在DNS查詢超時時會返回400或者500錯誤。

```
